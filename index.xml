<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://cutter.re//index.xml" rel="self" type="application/atom+xml" /><link href="https://cutter.re//" rel="alternate" type="text/html" /><updated>2025-05-14T19:18:43+00:00</updated><id>https://cutter.re//index.xml</id><title type="html">Cutter</title><subtitle>Free and Open Source RE Platform powered by Rizin</subtitle><entry><title type="html">Cutter 2.0 Release</title><link href="https://cutter.re//cutter-2.0" rel="alternate" type="text/html" title="Cutter 2.0 Release" /><published>2021-03-29T00:00:00+00:00</published><updated>2021-03-29T00:00:00+00:00</updated><id>https://cutter.re//cutter-2.0</id><content type="html" xml:base="https://cutter.re//cutter-2.0"><![CDATA[<style>
	figure
	{
		text-align: center;
		font-size: 0.8em;
		margin: 0;
		margin-bottom: 2em;
	}

	figure img
	{
		max-width: 100% !important;
		width: auto !important;
		margin-bottom: 0 !important;
	}
</style>

<p>We are excited to release Cutter v2.0 — the first release of Cutter that is using <a href="https://rizin.re">Rizin</a> as its core backend. Since forking radare2 and creating Rizin, we invested countless hours in improving the projects feature, overall stability, and the way we work. Releasing Cutter 2.0 is a significant milestone for us, as we believe that the recent improvements we made to our core — Rizin, and to Cutter itself, are the starting point of creating a better reverse engineering software.</p>

<p>Many of you waited for our first release with Rizin, and now the time has finally arrived. In this post, we note down some of the recent changes we have made to Cutter and what you should expect to see in this new release. To view the detailed changelog or download Cutter 2.0,
check out the <a href="https://github.com/rizinorg/cutter/releases/tag/v2.0.0">release on GitHub</a>!</p>

<h1 id="highlights">Highlights</h1>

<h2 id="saving-and-loading-your-work-with-projects">Saving and loading your work with Projects</h2>

<p>During reverse-engineering sessions, it is crucial to be able to keep track of the gained knowledge through annotations such as comments, function and variable names. As such, the tool one is working with also needs to provide a reliable and future-proof way to save and restore this information. This functionality was deeply important to us and to our users and was requested by the community often.</p>

<p>Up to this release, Cutter had only a basic and unreliable support for saving the user’s work in projects, a functionality provided by radare2. When Rizin was forked from radare2, the team decided to create a reliable mechanism of saving and loading projects from scratch. The technical details of this newly created projects feature are described in a <a href="https://rizin.re/posts/introducing-projects/">dedicated post published in rizin’s blog</a>.</p>

<p>Cutter 2.0 introduces full support for Projects, and you can now save and load you work seamlessly. The feature is in beta support that will last until the first major release of Rizin (v1.0).</p>

<p>By the way, because Cutter directly uses Rizin’s project format, projects created in command-line Rizin can be directly loaded in Cutter and vice-versa, giving you the possibility to change between both tools whenever you want.</p>

<h3 id="saving-a-project">Saving a project</h3>

<p>Saving your work in a project is simple and intuitive. Click on the “File” menu and choose “Save Project” or “Save Project As”. This will open a dialog that will ask you where do you want to save the new project. The extension for Rizin and Cutter projects is <code class="language-plaintext highlighter-rouge">.rzdb</code>.</p>

<p>Those of you who wish to use keyboard shortcuts can use <code class="language-plaintext highlighter-rouge">Ctrl + S</code> to save the project. You can use these shortcuts many times during your work to save the changes to the project file.</p>

<figure>
  <img src="/assets/images/blog/posts/cutter-2.0/save-project-menu.png" alt="Save Project Menu" />
</figure>

<h3 id="loading-projects">Loading projects</h3>

<p>Opening projects in Cutter can be done in two ways. The first one, is from the Projects tab in Cutter’s opening dialog. To do this, open Cutter and click on the Projects tab. In there, you will see the recent projects you created or loaded. Double-click on a project, or click “select” and choose another project file from the dialog.</p>

<figure>
  <img src="/assets/images/blog/posts/cutter-2.0/open-project-dialog.png" alt="Open Project Dialog" style="max-height: 500px;" />
</figure>

<p>The second option to open a project in Cutter is via the command line. To do this, run Cutter with the <code class="language-plaintext highlighter-rouge">-p</code> or <code class="language-plaintext highlighter-rouge">--project</code> flag:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cutter -p demo.rzdb
</code></pre></div></div>

<h2 id="cutter-now-supports-reverse-debugging">Cutter now supports Reverse Debugging</h2>

<p>Another feature that we’re very excited about in this release is the addition of reverse debugging to all debug backends, including remote and ESIL. Reverse debug allows you to move the program counter backwards and revert the program state to the saved state at that point.</p>

<p>The debug toolbar now includes the option to start a ‘trace session’ that enables reverse debug:</p>

<figure>
  <img src="/assets/images/blog/posts/cutter-2.0/debug-toolbar.png" alt="Debug Toolbar" />
</figure>

<p>Once you start a trace session, Cutter begins recording the program’s memory and register changes from the current program counter. This allows you to step backwards and continue backwards to restore the program’s state up to the trace session’s first recorded instruction:</p>

<figure>
  <img src="/assets/images/blog/posts/cutter-2.0/debug-toolbar-started.png" alt="Debug Toolbar while Debugging" />
  <figcaption>From right to left - stop trace session, continue backwards and step backwards</figcaption>
</figure>

<p>When stepping or continuing back, we locate the target instruction in the recorded session and revert the state of the registers and memory up to that point. It’s important to note that Cutter doesn’t handle non-deterministic events like signals or syscalls.</p>

<p><strong>Continuing back to the future</strong></p>

<p>Similarly to regular continue, backwards continue currently only stops due to an interrupt (by clicking on the “suspend process” button) or a breakpoint. Otherwise, it will continue all the way back to the session’s first instruction.</p>

<p>Since Cutter stops at every instruction to record memory and register changes while continuing, this may significantly slow down the traversal between two points. To solve this issue, we have also added the <code class="language-plaintext highlighter-rouge">dbg.trace_continue</code>(default=true) flag to the debug settings. This flag allows the user to save the program’s state only between two states: the first state is the original program counter position before continue, and the second is the destination of the run. This means that stepping backwards will also return to the last recorded point before continue as illustrated:</p>

<figure>
  <img src="/assets/images/blog/posts/cutter-2.0/debug-trace-continue-false.png" alt="dbg.trace_continue=false" />
  <figcaption>Continue with <code class="highlighter-rouge">dbg.trace_continue=false</code></figcaption>
</figure>

<figure>
  <img src="/assets/images/blog/posts/cutter-2.0/debug-trace-continue-false-back.png" alt="dbg.trace_continue=false" />
  <figcaption>Stepping back after continue with <code class="highlighter-rouge">dbg.trace_continue=false</code></figcaption>
</figure>

<p>Compared to being able to step back to any point after continue with <code class="language-plaintext highlighter-rouge">dbg.trace_continue=true</code>:</p>

<figure>
  <img src="/assets/images/blog/posts/cutter-2.0/debug-trace-continue-true.png" alt="dbg.trace_continue=true" />
  <figcaption>Continue with <code class="highlighter-rouge">dbg.trace_continue=true</code></figcaption>
</figure>

<figure>
  <img src="/assets/images/blog/posts/cutter-2.0/debug-trace-continue-true-back.png" alt="dbg.trace_continue=true" />
  <figcaption>Stepping back after continue with <code class="highlighter-rouge">dbg.trace_continue=true</code></figcaption>
</figure>

<h2 id="improving-the-renaming-workflow">Improving the renaming workflow</h2>

<p>Last year, we asked you what are the things you want to see improved in Cutter. Many of you mentioned that the basic workflow of renaming isn’t user-friendly and can be improved. And indeed, during the recent months we worked on improving it and created an easier renaming workflow in which you can press <code class="language-plaintext highlighter-rouge">N</code> in many places in the disassembly to rename functions, flags, and more. You can also use <code class="language-plaintext highlighter-rouge">N</code> to add new flags in certain addresses.</p>

<p>There are more improvement to do when it comes to renaming in Cutter, such as having better support for renaming symbols and renaming information in the decompiler. We plan to improve these areas in future releases.</p>

<h2 id="basic-block-headers-in-graph-view">Basic block headers in Graph view</h2>

<p>A new feature that was added in Cutter v2.0 is the option to display the basic blocks offsets in the Graph view. When enabled, each basic block will have its start-address displayed at the top. This feature can be enabled or disabled from the preferences view: Edit → Preferences → Disassembly → Graph → Show offset of the first instruction in each graph block.</p>

<figure>
  <img src="/assets/images/blog/posts/cutter-2.0/bb-headers.png" alt="Basic Block Headers" />
</figure>

<h2 id="hover-on-address-to-view-its-content">Hover on address to view its content</h2>

<p>The functions widget of Cutter had a functionality that allowed the user to preview the contents of a function by hovering with their mouse on a function name from the list. Now, in our new release, we expanded this feature and added support for previewing the contents of a function, flag or address, by hovering on them in the disassembly view. This will allow you to quickly view data and code in target address, without navigating to this address.</p>

<figure>
  <img src="/assets/images/blog/posts/cutter-2.0/hover-addr.png" alt="Hover on address" />
</figure>

<h2 id="new-comment-column-in-multiple-table-views">New Comment Column in multiple Table Views</h2>

<p>We improved multiple table view widgets to now display comments that are being added in these addresses. For example, if the user added a comment to an offset of a string, or of a flag, the comments will be displayed in the list.</p>

<figure>
  <img src="/assets/images/blog/posts/cutter-2.0/comment-col.png" alt="Comment Column" />
</figure>]]></content><author><name>Cutter Team</name></author><category term="Cutter" /><category term="Release" /><category term="Rizin" /><category term="Release" /><category term="Rizin" /><summary type="html"><![CDATA[We are excited to release Cutter v2.0 - our first release with Rizin.]]></summary></entry><entry><title type="html">Improving Decompiler Widget - GSoC Project</title><link href="https://cutter.re//improving-decompiler-widget-gsoc" rel="alternate" type="text/html" title="Improving Decompiler Widget - GSoC Project" /><published>2020-08-31T00:00:00+00:00</published><updated>2020-08-31T00:00:00+00:00</updated><id>https://cutter.re//improving-decompiler-widget-gsoc</id><content type="html" xml:base="https://cutter.re//improving-decompiler-widget-gsoc"><![CDATA[<p>My name is Nirmal Manoj. I am a second-year CS undergraduate student at IIIT Hyderabad, India. This summer, I participated in a <a href="https://summerofcode.withgoogle.com/">Google Summer of Code</a> project for <a href="https://github.com/radareorg/">radareorg</a>. The main goal of my project is to improve the decompiler interface in Cutter.</p>

<p>As a part of my project, I worked on multiple repositories, including <a href="https://github.com/radareorg/cutter/">Cutter</a>, <a href="https://github.com/radareorg/r2ghidra-dec/">r2ghidra-dec</a>, and <a href="https://github.com/radareorg/radare2/">radare2</a>. I have also sent a couple of patches to the <a href="https://github.com/avast/retdec-r2plugin">retdec-r2plugin</a>. The following sections sum up the important work that I have done and its impacts. Each section will describe specific features or important API that I have worked on. It will also have links to the code and discussions related to that topic.</p>

<h2 id="creating-a-standard-decompiler-interface">Creating a standard decompiler interface</h2>

<p>Cutter’s decompiler didn’t have a good enough decompiler interface for supporting context-sensitive actions. A basic structure named <code class="language-plaintext highlighter-rouge">RAnnotatedCode</code> and some useful API functions were already present in r2ghidra-dec for storing the information we get from the Ghidra decompiler.</p>

<p>After discussions in the community, we decided to use <code class="language-plaintext highlighter-rouge">RAnnotatedCode</code> as the standard decompiler interface across all the decompilers used in Cutter and Radare2. The related work involved shifting <code class="language-plaintext highlighter-rouge">RAnnotatedCode</code> API from r2ghidra-dec to radare2. I also implemented unit tests for API functions related to <code class="language-plaintext highlighter-rouge">RAnnotatedCode</code>.</p>

<p>Currently, Cutter supports three decompilers: <a href="https://github.com/radareorg/r2ghidra-dec">R2Ghidra</a>(plugin for Ghidra), <a href="https://github.com/radareorg/r2dec-js">R2Dec</a>, and <a href="https://github.com/avast/retdec-r2plugin">RetDec-Radare2</a>(plugin for RetDec). The output from all these decompilers was being parsed into a custom structure named <code class="language-plaintext highlighter-rouge">AnnotatedCode</code> to use in Cutter.  Even then, internally, r2ghidra-dec and retdec-radare2 used <code class="language-plaintext highlighter-rouge">RAnnotatedCode</code>. After I shifted <code class="language-plaintext highlighter-rouge">RAnnotatedCode</code> to radare2, I sent patches to both r2ghidra-dec and retdec-radare2 to use <code class="language-plaintext highlighter-rouge">RAnnotatedCode</code> directly from radare2.</p>

<h3 id="related-prs">Related PRs:</h3>

<ol>
  <li>radare2 <a href="https://github.com/radareorg/radare2/pull/16939">PR #16939</a>: Shifting RAnnotatedCode to radare2</li>
  <li>r2ghidra-dec <a href="https://github.com/radareorg/r2ghidra-dec/pull/107">PR #107</a>: Patching r2ghidra-dec after migrating RAnntoatedCode to use radare2</li>
  <li>retdec-r2plugin <a href="https://github.com/avast/retdec-r2plugin/pull/16">PR #16</a>: Patching retdec-r2plugin after migrating RAnnotatedCode to radare2</li>
</ol>

<h2 id="allow-cutter-to-use-rannotatedcode-for-the-decompiler">Allow Cutter to use RAnnotatedCode for the decompiler</h2>

<p>This involved refactoring the decompiler widget to use <code class="language-plaintext highlighter-rouge">RAnnotatedCode</code> instead of the custom <code class="language-plaintext highlighter-rouge">AnnotatedCode</code> it has been using. Using <code class="language-plaintext highlighter-rouge">RAnnotatedCode</code> will enable Cutter to have more data about the decompiled code that is essential for implementing a dedicated context menu. I also refactored the decompiler plugins (r2dec, r2ghidra-dec, r2retdec) to emit RAnnotatedCode directly to Cutter.</p>

<h3 id="related-prs-1">Related PRs:</h3>

<ol>
  <li>cutter <a href="https://github.com/radareorg/cutter/pull/2227">PR #2227</a>: Refactored Decompiler Widget and R2Dec Plugin to use RAnnotatedCode. 
 The description of this PR contains more precise details on the significant changes.</li>
  <li>r2ghidra-dec <a href="https://github.com/radareorg/r2ghidra-dec/pull/112">PR #112</a>: Emit RAnnotatedCode to Cutter</li>
  <li>retdec-r2plugin <a href="https://github.com/avast/retdec-r2plugin/pull/17">PR #16</a>: Emit RAnnotatedCode from decompileAt()</li>
</ol>

<h2 id="implementing-a-skeleton-for-the-decompiler-context-menu">Implementing a skeleton for the decompiler context menu</h2>

<p>This involves me making a context-menu with a single action for the decompiler. I replaced the disassembly context menu completely in the decompiler widget. The only action implemented along with the context menu skeleton was an action to copy selected decompiled code.</p>

<p>GIF that shows the decompiler context menu with just copy action
<img src="/assets/images/blog/posts/improving-decompiler-widget-gsoc/skeleton-copy.gif" alt="skeleton-copy" /></p>

<h3 id="related-pr">Related PR:</h3>
<ol>
  <li>cutter <a href="https://github.com/radareorg/cutter/pull/2256">PR #2256</a>: Dedicated decompiler context menu (skeleton) with an action to copy selected code</li>
</ol>

<h2 id="implementing-actions-for-debugging">Implementing actions for debugging</h2>
<p>This involved me implementing actions for toggling breakpoint, accessing the menu for advanced breakpoint definition, and also for two other debugging related actions in the decompiler context menu. Multiple breakpoints could exist in a decompiled code line, as that’s often a more straightforward representation of multiple lines in assembly. The option to choose the breakpoint that a user wants to edit from the breakpoints list was also implemented.</p>

<p>The following GIFs show key functionalities.</p>

<p>Demonstrating toggling of breakpoints
<img src="/assets/images/blog/posts/improving-decompiler-widget-gsoc/toggle-breakpoint.gif" alt="toggle-breakpoint" /></p>

<p>Demonstrating the ability to choose the breakpoint in a line for opening the edit breakpoint menu.
<img src="/assets/images/blog/posts/improving-decompiler-widget-gsoc/edit-advanced-breakpoint.gif" alt="edit-advanced-breakpoint" /></p>

<h3 id="related-pr-1">Related PR</h3>
<ol>
  <li>cutter <a href="https://github.com/radareorg/cutter/pull/2260">PR #2260</a>: Breakpoint Menu and Debug Menu in the Decompiler Context Menu</li>
</ol>

<h2 id="insertion-and-manipulation-of-comments-in-the-decompiled-code">Insertion and manipulation of comments in the decompiled code</h2>
<p>This involves implementing offset annotation for comments in r2ghidra-dec and implementing actions to add, edit, and delete comments in the decompiler context menu.</p>

<p>The following GIF demonstrates the actions.
<img src="/assets/images/blog/posts/improving-decompiler-widget-gsoc/comment-display.gif" alt="comment-display" /></p>

<h3 id="related-prs-2">Related PRs</h3>
<ol>
  <li>cutter <a href="https://github.com/radareorg/cutter/pull/2265">PR #2265</a>: Comment-related actions for the Decompiler Context Menu</li>
  <li>r2ghidra-dec <a href="https://github.com/radareorg/r2ghidra-dec/pull/121">PR #121</a>: Implemented offset annotation for comments</li>
</ol>

<h2 id="implementing-function-name-annotation-and-rename-function-action">Implementing function name annotation and rename function action</h2>
<p>This involved introducing a new type of annotation for function names in radare2 and implementing an annotator to annotate function names in r2ghidra-dec. I have also implemented a rename function action along with these. Other actions are implemented using this annotation. They will be shown in later sections.</p>

<p>GIF demonstrating rename function action:
<img src="/assets/images/blog/posts/improving-decompiler-widget-gsoc/rename-function-action.gif" alt="rename-function-action" /></p>

<h3 id="related-prs-3">Related PRs</h3>
<ol>
  <li>radare2 <a href="https://github.com/radareorg/radare2/pull/17204">PR #17204</a>: Annotation for function name</li>
  <li>r2ghidra-dec <a href="https://github.com/radareorg/r2ghidra-dec/pull/123">PR #123</a>: Function name annotation annotator implemented</li>
  <li>cutter <a href="https://github.com/radareorg/cutter/pull/2286">PR #2286</a>: Action to rename functions in the decompiler context menu</li>
</ol>

<h2 id="implementing-annotations-for-global-variables-constant-variables-and-related-actions">Implementing annotations for global variables, constant variables, and related actions</h2>
<p>This involved consolidating all references (function names, global variables, and constant variables) under a single structure called a “reference”. Two new annotation types were also introduced to accommodate global variables and constant variables. Also, annotators were implemented for these new types of annotations in r2ghidra-dec.</p>

<p>The decompiled code shown in the decompiler widget represents and refers to specific memory addresses in the binary. The ability to view these addresses in other widgets such as Hexdump or Disassembly can be very handy. For this, I created a “show-in” menu that allows the user to open the address related to the decompiled code under the cursor in other widgets. These other widgets include Hexdump, Graph, and Disassembly. One other related feature that can become useful is opening a reference in another widget. For instance, a function referenced under the cursor can be opened in a new decompiler widget or a graph widget. A targeted show-in menu for references was implemented for this. In this same PR, actions for adding, renaming, and deleting global variable names were implemented. See GIFs below to see the functionality implemented.</p>

<p>Along with these features, actions for copying instruction address and also reference’s address were implemented. The normal copy action was enhanced to copy a highlighted word to the clipboard if there is no text currently selected by the user. In the event where there is no highlighted word or selection, the entire line of code under the cursor will be copied to the clipboard.</p>

<p>Demonstrating show-in menu
<img src="/assets/images/blog/posts/improving-decompiler-widget-gsoc/show-in-disassembly.gif" alt="show-in-disassembly" /></p>

<p>Demonstrating targeted show-in menu. Here, the function referenced under the cursor is opened in a new widget.
<img src="/assets/images/blog/posts/improving-decompiler-widget-gsoc/show-in-new-graph.gif" alt="show-in-new-graph" /></p>

<p>Demonstrating adding, renaming, and deleting global variable names
<img src="/assets/images/blog/posts/improving-decompiler-widget-gsoc/manipulate-global-variable.gif" alt="manipulate-global-variable" /></p>

<p>Demonstrating enhanced copy action
<img src="/assets/images/blog/posts/improving-decompiler-widget-gsoc/copy-actions.gif" alt="copy-actions" /></p>

<h3 id="related-prs-4">Related PRs</h3>
<ol>
  <li>radare2 <a href="https://github.com/radareorg/radare2/pull/17281">PR #17281</a>: Annotations for Constant Variables and Global Variables for the decompiler</li>
  <li>r2ghidra-dec <a href="https://github.com/radareorg/r2ghidra-dec/pull/124">PR #124</a>: Annotation for constant and global variables</li>
  <li>cutter <a href="https://github.com/radareorg/cutter/pull/2295">PR #2295</a>: Show-in menu for references and add/rename/delete name for global variables</li>
</ol>

<h2 id="x-refs-action-in-the-decompiler-and-x-refs-for-variables-in-other-widgets">X-Refs action in the decompiler and X-Refs for variables in other widgets</h2>
<p>This involved making an action to show X-Refs to a reference (functions, global variables, constant variables with an address) in the decompiler. I have also implemented an action to show X-Refs for local variables and arguments in the disassembly context menu. The following GIFs demonstrate these actions:</p>

<p>X-Refs for variables in the disassembly widgets
<img src="/assets/images/blog/posts/improving-decompiler-widget-gsoc/xrefs-for-variables.gif" alt="xrefs-for-variables" /></p>

<p>X-Refs for references in the decompiler context menu
<img src="/assets/images/blog/posts/improving-decompiler-widget-gsoc/xrefs-for-references.gif" alt="xrefs-for-references" /></p>

<h3 id="related-prs-5">Related PRs</h3>
<ol>
  <li>cutter <a href="https://github.com/radareorg/cutter/pull/2297">PR #2297</a>: X-refs for variables</li>
  <li>cutter <a href="https://github.com/radareorg/cutter/pull/2352">PR #2352</a>: X-Refs for references</li>
</ol>

<h2 id="edit-local-variables-and-function-arguments">Edit local variables and function arguments</h2>
<p>This involved introducing two new types of annotations as well as implementing the required annotators in r2ghidra-dec. In Cutter, actions have been implemented for renaming and editing local variables and function arguments. Only variables that are present in the disassembly will be editable. The following GIF demonstrates the two actions:
<img src="/assets/images/blog/posts/improving-decompiler-widget-gsoc/manipulate-local-variable.gif" alt="manipulate-local-variable" /></p>

<h3 id="related-prs-6">Related PRs</h3>
<ol>
  <li>radare2 <a href="https://github.com/radareorg/radare2/pull/17375">PR #17375</a>: Annotation for local variables</li>
  <li>r2ghidra-dec <a href="https://github.com/radareorg/r2ghidra-dec/pull/128">PR #128</a>: Annotator for local variables and function parameters</li>
  <li>cutter <a href="https://github.com/radareorg/cutter/pull/2357">PR #2357</a>: Edit/Rename Variables Actions for function variables</li>
  <li>radare2 <a href="https://github.com/radareorg/radare2/pull/17386">PR #17386</a>: API for checking if an annotation is a reference or function variable</li>
</ol>

<h2 id="documentation-unit-tests-final-clean-up-and-merging-to-master">Documentation, Unit tests, Final clean-up, and Merging to Master</h2>
<p>A dedicated context-menu has been implemented by the PRs linked in the previous sections. All of these changes from the skeleton of the decompiler context menu were merged into branches named ‘decompiler-refactoring’ in the involved repositories. This was merged to master.</p>

<p>Before merging to master, the new code was documented, and unit tests were made for new annotations and API functions in radare2. The final clean-up removed unnecessary parts after careful observation.</p>

<h3 id="related-prs-7">Related PRs</h3>
<ol>
  <li>radare2 <a href="https://github.com/radareorg/radare2/pull/17397">PR #17397</a>: Update docs in annotate code API</li>
  <li>radare2 <a href="https://github.com/radareorg/radare2/pull/17403">PR #17403</a>: Unit tests for annotated code API</li>
  <li>cutter <a href="https://github.com/radareorg/cutter/pull/2374">PR #2374</a>: Code Documentation + Final Clean Up</li>
</ol>

<h4 id="the-following-prs-merge-all-the-changes-to-the-master-branch">The following PRs merge all the changes to the master branch</h4>
<ol>
  <li>radare2 <a href="https://github.com/radareorg/radare2/pull/17429">PR #17429</a>: New annotations and API functions for the decompiler</li>
  <li>r2ghidra-dec <a href="https://github.com/radareorg/r2ghidra-dec/pull/129">PR #129</a>: Annotators for new annotations</li>
  <li>cutter <a href="https://github.com/radareorg/cutter/pull/2391">PR #2391</a>: Enhanced Decompiler Widget with new Dedicated Context Menu</li>
</ol>

<h2 id="synchronized-decompiler-and-enabling-multiple-decompiler-widgets">Synchronized Decompiler and Enabling Multiple Decompiler Widgets</h2>
<p>The existing auto-refresh mechanism with a refresh button was often confusing to users, particularly when the auto-refresh is disabled. In this case, questions like whether renaming a reference or editing instruction in disassembly should reflect on the decompiler were often asked. Moreover, there were multiple benefits to making the decompiler widget a syncable widget like disassembly or graph. These are explained in the issue <a href="https://github.com/radareorg/cutter/issues/2370">#2370</a>. Allowing multiple decompiler widgets to be opened simultaneously will enable users to compare the output of multiple decompilers that Cutter supports, e.g., Ghidra, RetDec, and R2Dec. This was an existing issue <a href="https://github.com/radareorg/cutter/issues/1766">#1766</a>. I solved these two issues. User documentation to the decompiler was also added.</p>

<p>The following image shows two decompiler widgets with different decompilers side by side.
<img src="/assets/images/blog/posts/improving-decompiler-widget-gsoc/ghidra-vs-r2dec.png" alt="ghidra-vs-r2dec" /></p>

<h3 id="related-prs-8">Related PRs</h3>
<ol>
  <li>cutter <a href="https://github.com/radareorg/cutter/pull/2402">PR #2402</a>: Synchronized Decompiler and Enabling Multiple Decompiler Widgets</li>
  <li>cutter <a href="https://github.com/radareorg/cutter/pull/2410">PR #2410</a>: Save the layout of the Decompiler Widgets</li>
  <li>cutter <a href="https://github.com/radareorg/cutter/pull/2394">PR #2394</a>: User documentation for the new decompiler</li>
</ol>

<h2 id="what-next">What Next?</h2>
<ol>
  <li>The context-sensitive annotations have been implemented only for R2Ghidra as of now. I have opened issues in both R2Dec (<a href="https://github.com/radareorg/r2dec-js/issues/220">issue #220</a>) R2RetDec (<a href="https://github.com/avast/retdec-r2plugin/issues/20">issue #20</a>) with details on the annotations that are required by the Cutter. Once all new annotations are available from these decompilers, they will support all the actions currently available for r2ghidra-dec. I have also implemented what’s required from the Cutter’s side to support R2Dec by <a href="https://github.com/radareorg/cutter/pull/2407">PR #2407</a>. This can be merged as soon as R2Dec gets patched to have all annotations.</li>
</ol>

<p><em>I haven’t mentioned every single PR I have made as part of my project here.</em> All my PRs and issues that I solved as part of my project is available at this GitHub project in the radareorg: <a href="https://github.com/orgs/radareorg/projects/1">Improving Decompiler Widget (GSoC)</a>.</p>

<h2 id="thanks">Thanks</h2>

<p>I want to thank my mentors Itay Cohen, Kārlis, and Florian Märkl for all their sincere support and guidance. I have come a long way and learned a lot of valuable things in the past three and a half months of GSoC. My GSoC project was the first significant real-world project that I worked on, and I am incredibly happy about the work that I was able to do, and it’s potential. This will not have been possible without the insightful reviews and advice of my mentors. I hope we will continue to work together for Cutter.</p>]]></content><author><name>Nirmal Manoj</name></author><category term="Cutter" /><category term="Decompiler" /><category term="GSoC" /><category term="Decompiler" /><category term="GSoC" /><summary type="html"><![CDATA[The decompiler widget is now responsive than ever! Read about the improvements made possible by Nirmal, a GSoC student]]></summary></entry><entry><title type="html">Cutter Community Survey 2020</title><link href="https://cutter.re//cutter-community-survey-2020" rel="alternate" type="text/html" title="Cutter Community Survey 2020" /><published>2020-05-20T00:00:00+00:00</published><updated>2020-05-20T00:00:00+00:00</updated><id>https://cutter.re//cutter-community-survey-2020</id><content type="html" xml:base="https://cutter.re//cutter-community-survey-2020"><![CDATA[<meta name="twitter:image:src" content="https://cutter.re/assets/images/blog/posts/survey-2020/survey2020.png" />

<p>The Cutter team is working hard to create a free and open-source reverse engineering framework that will give you the best RE experience. Our 2020 community survey is here and this is our opportunity to get to know you better.</p>

<p>We already interact with many of you frequently using Telegram, IRC, and Twitter, but the interactions tend to be about specific problems. We want to hear from all of you, all the way from those who found it too difficult to start with Cutter to those who have contributed several times. We want to hear what you love about Cutter and what you hate about it. We want to hear about your smallest annoyances and problems that may take 5 years to solve. Anything goes. It’s only with your help that we can make Cutter into a truly useful tool.</p>

<p>Please take a few minutes to fill the survey. We’ll collect responses for about a month and then we’ll publish the results on our blog, groups and social media.</p>

<p><a href="https://forms.gle/rVwWVktbwZxbaPpF8" target="_blank" class="dwn-btn3 btn btn-primary"><span>Take the survey!</span></a></p>
<but>
</but>]]></content><author><name>Cutter Team</name></author><category term="Cutter" /><category term="Community" /><category term="Survey" /><category term="Community" /><summary type="html"><![CDATA[Our 2020 community survey is here and this is our opportunity to get to know you better.]]></summary></entry><entry><title type="html">5 Ways to patch binaries with Cutter</title><link href="https://cutter.re//5-ways-to-patch-binaries-with-cutter" rel="alternate" type="text/html" title="5 Ways to patch binaries with Cutter" /><published>2019-12-26T00:00:00+00:00</published><updated>2019-12-26T00:00:00+00:00</updated><id>https://cutter.re//5-ways-to-patch-binaries-with-cutter</id><content type="html" xml:base="https://cutter.re//5-ways-to-patch-binaries-with-cutter"><![CDATA[<p>I recently watched <a href="https://www.youtube.com/watch?v=LyNyf3UM9Yc">a video</a> by LiveOverflow in which he showed how different tools are used to patch binaries. By demonstrating some of the features that Radare2, Ghidra, and Binary Ninja offer for the task, the viewer can get some sense of the things they can get from using these tools.</p>
<p>While all these tools are great, and although Radare2 was showed there (and oh boy, things went wrong), there was one tool, which is dear to my heart, that wasn’t there – <a href="https://cutter.re/">Cutter</a>. Notwithstanding that it is the youngest member of the pack, Cutter is growing up very fast and when it has to do with binary patching – it does not stay behind.</p>
<p>“Binary Patching”, for those the term is unfamiliar, is the process of applying small changes and modifications to a binary file, usually in order to change its behavior. By modifying data or code, the user can change certain values in the program or specific instructions, and adjust the binary to their desired outcome.</p>

<p>Cutter makes patching binaries a simple task - here are 5 ways to do so.</p>

<p><a href="https://www.megabeets.net/5-ways-to-patch-binaries-with-cutter/" target="_blank" class="dwn-btn3 btn btn-primary"><span>Read on Megabeets’ website</span></a></p>
<but>
</but>]]></content><author><name>Itay Cohen</name></author><category term="Cutter" /><category term="Patching" /><summary type="html"><![CDATA[I recently watched a video by LiveOverflow in which he showed how different tools are used to patch binaries. By demonstrating some of the features that Radare2, Ghidra, and Binary Ninja offer for the task, the viewer can get some sense of the things they can get from using these tools. While all these tools are great, and although Radare2 was showed there (and oh boy, things went wrong), there was one tool, which is dear to my heart, that wasn’t there – Cutter. Notwithstanding that it is the youngest member of the pack, Cutter is growing up very fast and when it has to do with binary patching – it does not stay behind. “Binary Patching”, for those the term is unfamiliar, is the process of applying small changes and modifications to a binary file, usually in order to change its behavior. By modifying data or code, the user can change certain values in the program or specific instructions, and adjust the binary to their desired outcome.]]></summary></entry><entry><title type="html">Defeating a Ransomware using Cutter’s Emulation</title><link href="https://cutter.re//defeating-a-ransomware-with-cutter" rel="alternate" type="text/html" title="Defeating a Ransomware using Cutter’s Emulation" /><published>2019-09-13T00:00:00+00:00</published><updated>2019-09-13T00:00:00+00:00</updated><id>https://cutter.re//defeating-a-ransomware-with-cutter</id><content type="html" xml:base="https://cutter.re//defeating-a-ransomware-with-cutter"><![CDATA[<p>Last week I attended the <a href="https://www.radare.org/con/2019/">r2con conference</a> for the first time (for those who haven't heard about it before, it is a reverse engineering conference focused on <a href="https://www.radare.org/r/">radare2</a>) and apart from listening to great talks, I signed up for the basic trainings since I had not used r2 in the past and my RE experience is quite basic. One of the trainings was "Dissecting binaries with Cutter" given by <a href="https://twitter.com/xarkes_">Antide Petit</a>, <a href="https://twitter.com/megabeets_">Itay cohen</a>, and <a href="https://twitter.com/thestr4ng3r">Florian Märkl</a>. It was an introduction to the official GUI application for r2, <a href="https://cutter.re/">Cutter</a>.</p>

<p>During the training, there were 3 different exercises and one of them was about reversing a binary called <em>"M1ghty Ransomware.exe"</em> which by the name of it, you can guess what it is. Along with the binary, there was also a PNG file called <em>"flag.png"</em> that was encrypted by the malware. We had to use Cutter to analyse the binary and figure out the encryption algorithms, the keys used for the encryption, and finally write a script to decrypt the png file. Sounds easy, right? Well, it took me a while to figure it out. Let's dissect it.</p>

<p><a href="http://camaya.co/posts/2019/09/11/defeating-a-ransomware-with-cutter/" target="_blank" class="dwn-btn3 btn btn-primary"><span>Read on Cristhian Amaya’s website</span></a></p>
<but>
</but>]]></content><author><name>Cutter Team</name></author><category term="Guest article" /><summary type="html"><![CDATA[Last week I attended the r2con conference for the first time (for those who haven't heard about it before, it is a reverse engineering conference focused on radare2) and apart from listening to great talks, I signed up for the basic trainings since I had not used r2 in the past and my RE experience is quite basic. One of the trainings was "Dissecting binaries with Cutter" given by Antide Petit, Itay cohen, and Florian Märkl. It was an introduction to the official GUI application for r2, Cutter.]]></summary></entry><entry><title type="html">Decrypting APT33’s Dropshot Malware with Radare2 and Cutter – Part 1</title><link href="https://cutter.re//analyzing-dropshot-part-1" rel="alternate" type="text/html" title="Decrypting APT33’s Dropshot Malware with Radare2 and Cutter – Part 1" /><published>2019-07-26T09:12:09+00:00</published><updated>2019-07-26T09:12:09+00:00</updated><id>https://cutter.re//analyzing-dropshot-part-1</id><content type="html" xml:base="https://cutter.re//analyzing-dropshot-part-1"><![CDATA[<h1 id="prologue">Prologue</h1>

<p>As a reverse engineer and malware researcher, the tools I use are super important for me. I have invested hours and hours in creating the best malware analysis environment for myself and chose the best tools for me and my needs. For the last two years, radare2 is my go-to tool for a lot of reverse-engineering tasks such as automating RE related work, scripting, CTFing, exploitation and more. That said, I almost never used radare2 for malware analysis, or more accurately, for analysis of malware for Windows.</p>
<p>The main reason was that radare2 command-line interface felt too clumsy, complicated and an over-kill. IDA Pro was simply better for these tasks, a quick inspection of functions, data structures, renaming, commenting, et cetera. It felt more intuitive for me and that what I was searching for while doing malware analysis. And then came Cutter.</p>

<p><a href="https://www.megabeets.net/decrypting-dropshot-with-radare2-and-cutter-part-1/" target="_blank" class="dwn-btn3 btn btn-primary"><span>Read on megabeets.net</span></a></p>
<but>
</but>]]></content><author><name>Itay Cohen</name></author><category term="Plugins Cutter" /><category term="Plugins" /><summary type="html"><![CDATA[Prologue]]></summary></entry><entry><title type="html">Decrypting APT33’s Dropshot Malware with Radare2 and Cutter – Part 2</title><link href="https://cutter.re//analyzing-dropshot-part-2" rel="alternate" type="text/html" title="Decrypting APT33’s Dropshot Malware with Radare2 and Cutter – Part 2" /><published>2019-07-26T09:12:09+00:00</published><updated>2019-07-26T09:12:09+00:00</updated><id>https://cutter.re//analyzing-dropshot-part-2</id><content type="html" xml:base="https://cutter.re//analyzing-dropshot-part-2"><![CDATA[<h1 id="prologue">Prologue</h1>

<p>Previously, in the first part of this article, we used Cutter, a GUI for radare2, to statically analyze APT33’s Dropshot malware. We also used radare2’s Python scripting capabilities in order to decrypt encrypted strings in Dropshot. If you didn’t read the first part yet, I suggest you do it <a href="https://www.megabeets.net/decrypting-dropshot-with-radare2-and-cutter-part-21">now</a>.</p>
<p>Today’s article will be shorter, now that we are familiar with cutter and r2pipe, we can quickly analyze another interesting component of Dropshot — an encrypted resource that includes Dropshot’s actual payload. So without further ado, let’s start.</p>

<p><a href="https://www.megabeets.net/decrypting-dropshot-with-radare2-and-cutter-part-2/" target="_blank" class="dwn-btn3 btn btn-primary"><span>Read on megabeets.net</span></a></p>
<but>
</but>]]></content><author><name>Itay Cohen</name></author><category term="Plugins Cutter" /><category term="Plugins" /><summary type="html"><![CDATA[Prologue]]></summary></entry></feed>